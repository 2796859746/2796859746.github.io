<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java课堂学习笔记</title>
      <link href="/posts/java-notes.html"/>
      <url>/posts/java-notes.html</url>
      
        <content type="html"><![CDATA[<h2 id="9-月-25-日-Java"><a href="#9-月-25-日-Java" class="headerlink" title="9 月 25 日-Java"></a>9 月 25 日-Java</h2><h3 id="Java-术语"><a href="#Java-术语" class="headerlink" title="Java 术语"></a>Java 术语</h3><ul><li><p>Frontend：前端</p></li><li><p>Backend：后端</p></li><li><p>DecOps：运维</p></li><li><p>React：React 开发</p></li><li><p>SysAdmin：系统管理</p></li><li><p>Android：安卓</p></li><li><p>DBA：数据库管理</p></li><li><p>AWS：云平台</p></li><li><p>QA：质量保证</p></li><li><p>Agile development：敏捷开发</p></li><li><p>protocol：协议</p></li><li><p>Basic Frontend Knowledge：基础的前端知识</p></li><li><p>OS and General Knowledge：操作系统和常识</p></li><li><p>Basic Usage of Git：Git 的基本语法</p></li><li><p>Version Control Systems：版本控制系统</p></li><li><p>Repo hosting services：仓库代码托管服务</p></li><li><p>DDD(Domain-driven design)：领域驱动设计</p></li><li><p>containerization VS virtualiation：容器化 vs 虚拟化</p></li><li><p>Web Security Knowledge：网络安全知识</p></li><li><p>WebSockets：网络套接字</p></li><li><p>Web Servers:Web 服务器</p></li></ul><h3 id="后端路线图"><a href="#后端路线图" class="headerlink" title="后端路线图"></a>后端路线图</h3><p><img src="https://i.loli.net/2021/09/25/2KNjYwWbHeMagpT.png"></p><h3 id="入门学习知识库资源"><a href="#入门学习知识库资源" class="headerlink" title="入门学习知识库资源"></a>入门学习知识库资源</h3><ul><li><a href="https://www.gettoby.com/p/7pv250tmv0fz">TOBY 学习资源</a></li><li><a href="https://www.programcreek.com/java-api-examples/index.php">Java 代码示例</a></li><li><a href="https://zh.learnlayout.com/">CSS 布局</a></li><li><a href="https://learn.shayhowe.com/html-css/">html&amp;css</a></li><li><a href="https://wangdoc.com/">网道</a></li><li><a href="https://www.gettoby.com/p/nrtdw65yccsj">阿里云</a></li></ul><h3 id="类型的种类和值"><a href="#类型的种类和值" class="headerlink" title="类型的种类和值"></a>类型的种类和值</h3><p>那 Java 支持哪些数据类型呢？</p><p>在 Java 的世界里，有<strong>基本类型</strong>和<strong>引用类型</strong>两种。相应地，有两种数据值可以存储在变量里，作为参数传递，由方法返回，并对其进行操作：<strong>原始值</strong>和<strong>引用值</strong>。</p><p><img src="https://i.loli.net/2021/09/25/NKnqUFJ1BGoVHru.png"></p><h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><p>基本数据类型在 Java 里可分为<strong>布尔类型</strong>和<strong>数字类型</strong>两大类：</p><p><img src="https://i.loli.net/2021/09/25/72WzP18vomehltp.png"></p><p>布尔类型表达是或否，只有<strong>true</strong>和<strong>false</strong>两个值，用关键字<strong>boolean</strong>表示，但 JVM 没有针对<strong>boolean</strong>的字节码指令，因此在虚拟机规范里,<strong>boolean</strong>类型在编译后会被<strong>int</strong>代替，占用 4 个字节，如果是 boolean 数组，会被编译成 <strong>byte</strong>数组类型，每个<strong>boolean</strong>数组元素占 1 个字节。实际情况就取决于各厂商发布的 JVM 实现了。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo+github搭建博客</title>
      <link href="/posts/hexo.html"/>
      <url>/posts/hexo.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>GitHub page 提供了免费的服务搭建</strong></p><ul><li>免费域名 xxx.github.io xxx 是你的 github 用户名</li><li>免费的代码存储空间</li><li>全是静态文件，快速访问</li><li>git 版本管理，能快速回滚或者切换的某个版本</li></ul><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="注册-GitHub-账号"><a href="#注册-GitHub-账号" class="headerlink" title="注册 GitHub 账号"></a>注册 GitHub 账号</h3><p>（如果拥有 GitHub 账号 无需重新注册）<br>点击 sign in 界面的 Create an account</p><img src="https://img.58cdn.com.cn/escstatic/fecar/pmuse/docmanager/hexo1.png"><p>注册信息填写：<br><img src="https://img.58cdn.com.cn/escstatic/fecar/pmuse/docmanager/hexo2.png"><br>注册完成之后直接登录</p><h3 id="node-环境"><a href="#node-环境" class="headerlink" title="node 环境"></a>node 环境</h3><p>本地安装 nodejs 环境，此处就不在详细介绍安装了。</p><h2 id="安装-git"><a href="#安装-git" class="headerlink" title="安装 git"></a>安装 git</h2><p>为了把本地的网页文件上传到 github 上面去，我们需要用到分布式版本控制工具————Git[<a href="https://git-scm.com/download/win">下载地址</a>]。</p><p>安装选项还是全部默认，只不过最后一步添加路径时选择<font color="#ffa500"> Use Git from the Windows Command Prompt</font>，这样我们就可以直接在命令提示符里打开 git 了。</p><p>安装完成后在命令提示符中输入<font color="#ffa500"> git –version </font>验证是否安装成功。</p><p>window 需要安装 git bash 或者其他工具来支持 git 命令的使用</p><h2 id="GitHub-博客注册"><a href="#GitHub-博客注册" class="headerlink" title="GitHub 博客注册"></a>GitHub 博客注册</h2><p>接下来就是去 GitHub 上注册一个 git page 来存放我们的博客静态页面</p><p>点击新增项目</p><p><img src="https://i.loli.net/2021/09/24/JQLpv2xGukrl83j.png"><br><img src="https://i.loli.net/2021/09/24/Bc2FSlyVeAEN8bq.png"><br>填写新增信息。</p><p><font color="#ffa500">填写注意事项:</font></p><ul><li>name 填写 XXX.github.io</li><li>上面的 XXX 就是你的 GitHub 用户名 owner</li><li>一定要填写.github.io 后缀 不然就创建成普通项目了<br>创建完成会自动生成<a href="https://2796859746.github.io/">https://2796859746.github.io/</a> 这样的访问地址</li></ul><p>Repository 那么一定要按规则填写 不然后期会出现博客代码提交不上去的问题<br><img src="https://i.loli.net/2021/09/24/kvs8L5cgqS1RWZT.png"><br>如果你的这个 page 地址已占用看是否能把它迁移到别的 page 下面</p><h2 id="配置-SSH-key"><a href="#配置-SSH-key" class="headerlink" title="配置 SSH key"></a>配置 SSH key</h2><p>在本地代码 push 是需要你的 GitHub 权限，但是直接使用用户名和密码太不安全了，所以我们使用 ssh key 来解决本地和服务器的连接问题。</p><h3 id="本地公钥生成"><a href="#本地公钥生成" class="headerlink" title="本地公钥生成"></a>本地公钥生成</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ssh-keygen -t rsa -C "邮箱地址"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><img src="https://img.58cdn.com.cn/escstatic/fecar/pmuse/docmanager/hexo6.png">如果本地目录下面已存在 直接覆盖原有的就可以<h3 id="GitHub-配置"><a href="#GitHub-配置" class="headerlink" title="GitHub 配置"></a>GitHub 配置</h3><p>setting&gt;SSH and GPG keys&gt;New SSH key</p><img src="https://img.58cdn.com.cn/escstatic/fecar/pmuse/docmanager/hexo8.png">copy本地刚刚生成的.ssh/id_rsa.pub里面的全部内容<img src="https://img.58cdn.com.cn/escstatic/fecar/pmuse/docmanager/hexo7.png">每个人生成的目录地址可能是不一样的，可以在ssh生成的时候看到你本地的生成地址<h3 id="检测是否添加成功"><a href="#检测是否添加成功" class="headerlink" title="检测是否添加成功"></a>检测是否添加成功</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ssh -T git@github.com # 注意邮箱地址不用改<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果提示<font color="ffa500">Are you sure you want to continue connecting (yes/no)?</font>，输入 yes，然后会看到：</p><blockquote><p>Hi gongchenghuigch! You’ve successfully authenticated, but GitHub does not provide shell access.</p></blockquote><p>看到这个信息说明 SSH 已配置成功</p><h3 id="git-全局设置"><a href="#git-全局设置" class="headerlink" title="git 全局设置"></a>git 全局设置</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">git config --global user.name "xxx"// 你的github用户名，非昵称git config --global user.email  "xxx@163.com"// 填写你的github注册邮箱<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="使用-hexo"><a href="#使用-hexo" class="headerlink" title="使用 hexo"></a>使用 hexo</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 <a href="http://daringfireball.net/projects/markdown/">Markdown</a>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><p><a href="https://hexo.io/zh-cn/docs/">hexo 中文文档</a></p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>由于 github pages 存放的都是静态文件，博客存放的不只是文章内容，还有文章列表、分类、标签、翻页等动态内容，假如每次写完一篇文章都要手动更新博文目录和相关链接信息，相信谁都会疯掉，所以 hexo 所做的就是将这些 md 文件都放在本地，每次写完文章后调用写好的命令来批量完成相关页面的生成，然后再将有改动的页面提交到 github。</p><h3 id="安装-hexo"><a href="#安装-hexo" class="headerlink" title="安装 hexo"></a>安装 hexo</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">npm install -g hexo-cli<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>在你电脑找一个文件目录下执行</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>执行完成会出现以下的目录结构：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">.├── \_config.yml├── package.json├── scaffolds├── source| ├── \_drafts| └── \_posts└── themes<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>_config.yml 网站的 配置 信息，您可以在此配置大部分的参数。</p><h3 id="本地启动"><a href="#本地启动" class="headerlink" title="本地启动"></a>本地启动</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo server 或者 hexo s<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><img src="https://img.58cdn.com.cn/escstatic/fecar/pmuse/docmanager/hexo9.png"><p>浏览器窗口访问 <a href="http://localhost:4000/">http://localhost:4000</a> 会出现以下页面：</p><img src="https://img.58cdn.com.cn/escstatic/fecar/pmuse/docmanager/hexo11.png"><p>这个是默认主题 比较丑陋；下面会介绍一些个人比较喜欢的主题。</p><h3 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h3><p>配置<font color="#ffa500">_config.yml</font>中有关 deploy 的部分：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">deploy:  type: git  repository: git@github.com:gongchenghuigch/gongchenghuigch.github.io.git  branch: master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>注意：</p><p>repository 不要写成 git clone 的 https 的地址</p><p>错误写法：</p><pre class="line-numbers language-none"><code class="language-none">deploy:  type: git  repository: https://github.com/gongchenghuigch/gongchenghuigch.github.io.git  branch: master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>配置完之后直接执行命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行完命名之后会在本地生成 public 打包的静态文件和.deploy_git 提交 git 的编译之后的静态文件<br><img src="https://img.58cdn.com.cn/escstatic/fecar/pmuse/docmanager/hexo12.png"><br>public 和.deploy_git 下编译的静态文件如下：</p><img src="https://img.58cdn.com.cn/escstatic/fecar/pmuse/docmanager/hexo13.png"><p>如果在开发过程中想看的编译的静态文件直接执行命令：</p><pre class="line-numbers language-none"><code class="language-none">hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注意：</p><p>在发布时如果本地已存在 public 需要执行 hexo clean 或者手动删除 public 目录，不然不会提交最新代码</p><h3 id="新增文章"><a href="#新增文章" class="headerlink" title="新增文章"></a>新增文章</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo new page test<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>hexo 会创建 source/test/index.md</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo new page --path _posts/text "测试页面"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>hexo 会创建 source/_posts/text.md 同时页面 title 为“测试页面”</p><!-- <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=450 src="//music.163.com/outchain/player?type=0&id=6964646956&auto=1&height=430"></iframe> -->]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS基础面试题</title>
      <link href="/posts/js-basic.html"/>
      <url>/posts/js-basic.html</url>
      
        <content type="html"><![CDATA[<h2 id="（2）问：0-1-0-2-0-3-嘛？为什么？"><a href="#（2）问：0-1-0-2-0-3-嘛？为什么？" class="headerlink" title="（2）问：0.1 + 0.2 === 0.3 嘛？为什么？"></a>（2）问：0.1 + 0.2 === 0.3 嘛？为什么？</h2><p>JavaScirpt 使用 Number 类型来表示数字（整数或浮点数），遵循 IEEE 754 标准，通过 64 位来表示一个数字（1 + 11 + 52）</p><ul><li>1 符号位，0 表示正数，1 表示负数 s</li><li>11 指数位（e）</li><li>52 尾数，小数部分（即有效数字）</li></ul><p>最大安全数字：Number.MAX_SAFE_INTEGER = Math.pow(2, 53) - 1，转换成整数就是 16 位，所以 0.1 === 0.1，是因为通过 toPrecision(16) 去有效位之后，两者是相等的。</p><p>在两数相加时，会先转换成二进制，0.1 和 0.2 转换成二进制的时候尾数会发生无限循环，然后进行对阶运算，JS 引擎对二进制进行截断，所以造成精度丢失。</p><p>所以总结：精度丢失可能出现在进制转换和对阶运算中</p><h2 id="（4）问：JS-数据类型"><a href="#（4）问：JS-数据类型" class="headerlink" title="（4）问：JS 数据类型"></a>（4）问：JS 数据类型</h2><p>基本类型：Number、Boolean、String、null、undefined、symbol（ES6 新增的），BigInt（ES2020） 引用类型：Object，对象子类型（Array，Function）</p><h2 id="问：JS-整数是怎么表示的？"><a href="#问：JS-整数是怎么表示的？" class="headerlink" title="问：JS 整数是怎么表示的？"></a>问：JS 整数是怎么表示的？</h2><ul><li>通过 Number 类型来表示，遵循 IEEE754 标准，通过 64 位来表示一个数字，（1 + 11 + 52），最大安全数字是 Math.pow(2, 53) - 1，对于 16 位十进制。（符号位 + 指数位 + 小数部分有效位）</li></ul><h2 id="问：Number-的存储空间是多大？如果后台发送了一个超过最大自己的数字怎么办"><a href="#问：Number-的存储空间是多大？如果后台发送了一个超过最大自己的数字怎么办" class="headerlink" title="问：Number() 的存储空间是多大？如果后台发送了一个超过最大自己的数字怎么办"></a>问：Number() 的存储空间是多大？如果后台发送了一个超过最大自己的数字怎么办</h2><p>Math.pow(2, 53) ，53 为有效数字，会发生截断，等于 JS 能支持的最大数字。</p><h2 id="（4）写代码：实现函数能够深度克隆基本类型"><a href="#（4）写代码：实现函数能够深度克隆基本类型" class="headerlink" title="（4）写代码：实现函数能够深度克隆基本类型"></a>（4）写代码：实现函数能够深度克隆基本类型</h2><p>浅克隆：</p><blockquote><p>function shallowClone(obj) {<br>let cloneObj = {};<br>for (let i in obj) {<br>cloneObj[i] = obj[i];<br>}<br>return cloneObj;<br>}</p></blockquote><p>深克隆：</p><ul><li>考虑基础类型</li><li>引用类型</li><li>RegExp、Date、函数 不是 JSON 安全的</li><li>会丢失 constructor，所有的构造函数都指向 Object</li><li>破解循环引用</li></ul><blockquote><p>function deepCopy(obj) {<br>if (typeof obj === ‘object’) {<br>var result = obj.constructor === Array ? [] : {};<br>for (var i in obj) {<br>result[i] = typeof obj[i] === ‘object’ ? deepCopy(obj[i]) : obj[i];<br>}<br>} else {<br>var result = obj;<br>}<br>return result;<br>}</p></blockquote><h2 id="问：事件流"><a href="#问：事件流" class="headerlink" title="问：事件流"></a>问：事件流</h2><p>事件流是网页元素接收事件的顺序，”DOM2 级事件”规定的事件流包括三个阶段：事件捕获阶段、处于目标阶段、事件冒泡阶段。首先发生的事件捕获，为截获事件提供机会。然后是实际的目标接受事件。最后一个阶段是时间冒泡阶段，可以在这个阶段对事件做出响应。虽然捕获阶段在规范中规定不允许响应事件，但是实际上还是会执行，所以有两次机会获取到目标对象。</p><pre class="line-numbers language-none"><code class="language-none">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;事件冒泡&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;div&gt;        &lt;p id="parEle"&gt;我是父元素    &lt;span id="sonEle"&gt;我是子元素&lt;/span&gt;&lt;/p&gt;    &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;script type="text/javascript"&gt;var sonEle = document.getElementById('sonEle');var parEle = document.getElementById('parEle');parEle.addEventListener('click', function () {alert('父级 冒泡');}, false);parEle.addEventListener('click', function () {alert('父级 捕获');}, true);sonEle.addEventListener('click', function () {alert('子级冒泡');}, false);sonEle.addEventListener('click', function () {alert('子级捕获');}, true);&lt;/script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当容器元素及嵌套元素，即在捕获阶段又在冒泡阶段调用事件处理程序时：事件按 DOM 事件流的顺序执行事件处理程序：</p><ul><li>父级捕获</li><li>子级冒泡</li><li>子级捕获</li><li>父级冒泡</li></ul><p>且当事件处于目标阶段时，事件调用顺序决定于绑定事件的书写顺序，按上面的例子为，先调用冒泡阶段的事件处理程序，再调用捕获阶段的事件处理程序。依次 alert 出“子集冒泡”，“子集捕获”。</p><h3 id="IE-兼容"><a href="#IE-兼容" class="headerlink" title="IE 兼容"></a>IE 兼容</h3><ul><li>attchEvent(‘on’ + type, handler)</li><li>detachEvent(‘on’ + type, handler)</li></ul><h2 id="问：事件是如何实现的？"><a href="#问：事件是如何实现的？" class="headerlink" title="问：事件是如何实现的？"></a>问：事件是如何实现的？</h2><p>基于发布订阅模式，就是在浏览器加载的时候会读取事件相关的代码，但是只有实际等到具体的事件触发的时候才会执行。</p><p>比如点击按钮，这是个事件（Event），而负责处理事件的代码段通常被称为事件处理程序（Event Handler），也就是「启动对话框的显示」这个动作。</p><p>在 Web 端，我们常见的就是 DOM 事件：</p><p>DOM0 级事件，直接在 html 元素上绑定 on-event，比如 onclick，取消的话，dom.onclick = null，同一个事件只能有一个处理程序，后面的会覆盖前面的。<br>DOM2 级事件，通过 addEventListener 注册事件，通过 removeEventListener 来删除事件，一个事件可以有多个事件处理程序，按顺序执行，捕获事件和冒泡事件<br>DOM3 级事件，增加了事件类型，比如 UI 事件，焦点事件，鼠标事件</p><h2 id="问：new-一个函数发生了什么"><a href="#问：new-一个函数发生了什么" class="headerlink" title="问：new 一个函数发生了什么"></a>问：new 一个函数发生了什么</h2><p>构造调用：</p><ul><li>创造一个全新的对象</li><li>这个对象会被执行 [[Prototype]] 连接，将这个新对象的 [[Prototype]] 链接到这个构造函数.prototype 所指向的对象</li><li>这个新对象会绑定到函数调用的 this</li><li>如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象</li></ul><h2 id="问：new-一个构造函数，如果函数返回-return-、-return-null-，-return-1-，-return-true-会发生什么情况？"><a href="#问：new-一个构造函数，如果函数返回-return-、-return-null-，-return-1-，-return-true-会发生什么情况？" class="headerlink" title="问：new 一个构造函数，如果函数返回 return {} 、 return null ， return 1 ， return true 会发生什么情况？"></a>问：new 一个构造函数，如果函数返回 return {} 、 return null ， return 1 ， return true 会发生什么情况？</h2><p>如果函数返回一个对象，那么 new 这个函数调用返回这个函数的返回对象，否则返回 new 创建的新对象</p><h2 id="问：symbol-有什么用处"><a href="#问：symbol-有什么用处" class="headerlink" title="问：symbol 有什么用处"></a>问：symbol 有什么用处</h2><p>可以用来表示一个独一无二的变量防止命名冲突。但是面试官问还有吗？我没想出其他的用处就直接答我不知道了，还可以利用 symbol 不会被常规的方法（除了 Object.getOwnPropertySymbols 外）遍历到，所以可以用来模拟私有变量。</p><p>主要用来提供遍历接口，布置了 symbol.iterator 的对象才可以使用 for···of 循环，可以统一处理数据结构。调用之后回返回一个遍历器对象，包含有一个 next 方法，使用 next 方法后有两个返回值 value 和 done 分别表示函数当前执行位置的值和是否遍历完毕。</p><p>Symbol.for() 可以在全局访问 symbol</p><h3 id="（3）问：闭包是什么？"><a href="#（3）问：闭包是什么？" class="headerlink" title="（3）问：闭包是什么？"></a>（3）问：闭包是什么？</h3><p>闭包是指有权访问另外一个函数作用域中的变量的函数</p><p>JavaScript 代码的整个执行过程，分为两个阶段，代码编译阶段与代码执行阶段。编译阶段由编译器完成，将代码翻译成可执行代码，这个阶段作用域规则会确定。执行阶段由引擎完成，主要任务是执行可执行代码，执行上下文在这个阶段创建。</p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gptg8nwgjaj30u00bbgm7.jpg"><h3 id="什么是作用域？"><a href="#什么是作用域？" class="headerlink" title="什么是作用域？"></a>什么是作用域？</h3><p>ES5 中只存在两种作用域：全局作用域和函数作用域。在 JavaScript 中，我们将作用域定义为一套规则，这套规则用来管理引擎如何在当前作用域以及嵌套子作用域中根据标识符名称进行变量（变量名或者函数名）查找</p><h3 id="什么是作用域链？"><a href="#什么是作用域链？" class="headerlink" title="什么是作用域链？"></a>什么是作用域链？</h3><p>首先要了解作用域链，当访问一个变量时，编译器在执行这段代码时，会首先从当前的作用域中查找是否有这个标识符，如果没有找到，就会去父作用域查找，如果父作用域还没找到继续向上查找，直到全局作用域为止,，而作用域链，就是有当前作用域与上层作用域的一系列变量对象组成，它保证了当前执行的作用域对符合访问权限的变量和函数的有序访问。</p><h3 id="闭包产生的本质"><a href="#闭包产生的本质" class="headerlink" title="闭包产生的本质"></a>闭包产生的本质</h3><p>当前环境中存在指向父级作用域的引用</p><h3 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h3><p>闭包是一种特殊的对象，它由两部分组成：执行上下文（代号 A），以及在该执行上下文中创建的函数 （代号 B），当 B 执行时，如果访问了 A 中变量对象的值，那么闭包就会产生，且在 Chrome 中使用这个执行上下文 A 的函数名代指闭包。</p><h3 id="一般如何产生闭包"><a href="#一般如何产生闭包" class="headerlink" title="一般如何产生闭包"></a>一般如何产生闭包</h3><ul><li>返回函数</li><li>函数当做参数传递</li></ul><h3 id="闭包的应用场景"><a href="#闭包的应用场景" class="headerlink" title="闭包的应用场景"></a>闭包的应用场景</h3><ul><li>柯里化 bind</li><li>模块</li></ul><h2 id="问：NaN-是什么，用-typeof-会输出什么？"><a href="#问：NaN-是什么，用-typeof-会输出什么？" class="headerlink" title="问：NaN 是什么，用 typeof 会输出什么？"></a>问：NaN 是什么，用 typeof 会输出什么？</h2><p>Not a Number，表示非数字，typeof NaN === ‘number’</p><h3 id="（2）问：JS-隐式转换，显示转换"><a href="#（2）问：JS-隐式转换，显示转换" class="headerlink" title="（2）问：JS 隐式转换，显示转换"></a>（2）问：JS 隐式转换，显示转换</h3><p>一般非基础类型进行转换时会先调用 valueOf，如果 valueOf 无法返回基本类型值，就会调用 toString</p><h4 id="字符串和数字"><a href="#字符串和数字" class="headerlink" title="字符串和数字"></a>字符串和数字</h4><p>“+” 操作符，如果有一个为字符串，那么都转化到字符串然后执行字符串拼接<br>“-“ 操作符，转换为数字，相减 (-a, a * 1 a/1) 都能进行隐式强制类型转换</p><blockquote><p>[] + {} 和 {} + []</p></blockquote><h4 id="布尔值到数字"><a href="#布尔值到数字" class="headerlink" title="布尔值到数字"></a>布尔值到数字</h4><ul><li>1 + true = 2</li><li>1 + false = 1</li></ul><h4 id="转换为布尔值"><a href="#转换为布尔值" class="headerlink" title="转换为布尔值"></a>转换为布尔值</h4><ul><li>for 中第二个</li><li>while</li><li>if</li><li>三元表达式</li><li>|| （逻辑或） &amp;&amp; （逻辑与）左边的操作数</li></ul><h4 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h4><ul><li>不能被转换为数字</li><li>能被转换为布尔值（都是 true）</li><li>可以被转换成字符串 “Symbol(cool)”</li></ul><h4 id="宽松相等和严格相等"><a href="#宽松相等和严格相等" class="headerlink" title="宽松相等和严格相等"></a>宽松相等和严格相等</h4><p>宽松相等允许进行强制类型转换，而严格相等不允许</p><h4 id="字符串与数字"><a href="#字符串与数字" class="headerlink" title="字符串与数字"></a>字符串与数字</h4><p>转换为数字然后比较</p><h4 id="其他类型与布尔类型"><a href="#其他类型与布尔类型" class="headerlink" title="其他类型与布尔类型"></a>其他类型与布尔类型</h4><ul><li>先把布尔类型转换为数字，然后继续进行比较</li></ul><h4 id="对象与非对象"><a href="#对象与非对象" class="headerlink" title="对象与非对象"></a>对象与非对象</h4><ul><li>执行对象的 ToPrimitive(对象）然后继续进行比较</li></ul><h4 id="假值列表"><a href="#假值列表" class="headerlink" title="假值列表"></a>假值列表</h4><ul><li>undefined</li><li>null</li><li>false</li><li>+0, -0, NaN</li><li>“”</li></ul><h3 id="（2）问：了解-this-嘛，bind，call，apply-具体指什么"><a href="#（2）问：了解-this-嘛，bind，call，apply-具体指什么" class="headerlink" title="（2）问：了解 this 嘛，bind，call，apply 具体指什么"></a>（2）问：了解 this 嘛，bind，call，apply 具体指什么</h3><p>它们都是函数的方法</p><p>call: Array.prototype.call(this, args1, args2]) apply: Array.prototype.apply(this, [args1, args2]) ：ES6 之前用来展开数组调用, foo.appy(null, [])，ES6 之后使用 … 操作符</p><ul><li>New 绑定 &gt; 显示绑定 &gt; 隐式绑定 &gt; 默认绑定</li><li>如果需要使用 bind 的柯里化和 apply 的数组解构，绑定到 null，尽可能使用 Object.create(null) 创建一个 DMZ 对象</li></ul><p>四条规则：</p><ul><li>默认绑定，没有其他修饰（bind、apply、call)，在非严格模式下定义指向全局对象，在严格模式下定义指向 undefined</li></ul><pre class="line-numbers language-none"><code class="language-none">function foo() {console.log(this.a);}var a = 2;foo();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>隐式绑定：调用位置是否有上下文对象，或者是否被某个对象拥有或者包含，那么隐式绑定规则会把函数调用中的 this 绑定到这个上下文对象。而且，对象属性链只有上一层或者说最后一层在调用位置中起作用</li></ul><pre class="line-numbers language-none"><code class="language-none">function foo() {console.log(this.a);}var obj = {a: 2,foo: foo,}obj.foo(); // 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>显示绑定：通过在函数上运行 call 和 apply ，来显示的绑定 this</li></ul><pre class="line-numbers language-none"><code class="language-none">function foo() {console.log(this.a);}var obj = {a: 2};foo.call(obj);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>显示绑定之硬绑定</li></ul><pre class="line-numbers language-none"><code class="language-none">function foo(something) {console.log(this.a, something);return this.a + something;}function bind(fn, obj) {return function() {return fn.apply(obj, arguments);};}var obj = {a: 2}var bar = bind(foo, obj);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>New 绑定，new 调用函数会创建一个全新的对象，并将这个对象绑定到函数调用的 this。</p><ul><li>New 绑定时，如果是 new 一个硬绑定函数，那么会用 new 新建的对象替换这个硬绑定 this，</li></ul><pre class="line-numbers language-none"><code class="language-none">function foo(a) {this.a = a;}var bar = new foo(2);console.log(bar.a)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="（4）问：手写-bind、apply、call"><a href="#（4）问：手写-bind、apply、call" class="headerlink" title="（4）问：手写 bind、apply、call"></a>（4）问：手写 bind、apply、call</h4><pre class="line-numbers language-none"><code class="language-none">// callFunction.prototype.call = function (context, ...args) {context = context || window;const fnSymbol = Symbol("fn");context[fnSymbol] = this;context[fnSymbol](...args);delete context[fnSymbol];}// applyFunction.prototype.apply = function (context, argsArr) {context = context || window;const fnSymbol = Symbol("fn");context[fnSymbol] = this;context[fnSymbol](...argsArr);delete context[fnSymbol];}// bindFunction.prototype.bind = function (context, ...args) {context = context || window;const fnSymbol = Symbol("fn");context[fnSymbol] = this;return function (...\_args) {args = args.concat(\_args);    context[fnSymbol](...args);    delete context[fnSymbol];}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="（3）问：setTimeout-fn-0-多久才执行，Event-Loop"><a href="#（3）问：setTimeout-fn-0-多久才执行，Event-Loop" class="headerlink" title="（3）问：setTimeout(fn, 0)多久才执行，Event Loop"></a>（3）问：setTimeout(fn, 0)多久才执行，Event Loop</h3><p>setTimeout 按照顺序放到队列里面，然后等待函数调用栈清空之后才开始执行，而这些操作进入队列的顺序，则由设定的延迟时间来决定</p><h2 id="手写题：Promise-原理"><a href="#手写题：Promise-原理" class="headerlink" title="手写题：Promise 原理"></a>手写题：Promise 原理</h2><pre class="line-numbers language-none"><code class="language-none">class MyPromise {constructor(fn) {this.resolvedCallbacks = [];this.rejectedCallbacks = [];    this.state = 'PENDING';    this.value = '';    fn(this.resolve.bind(this), this.reject.bind(this));}resolve(value) {if (this.state === 'PENDING') {this.state = 'RESOLVED';this.value = value;      this.resolvedCallbacks.map(cb =&gt; cb(value));    }}reject(value) {if (this.state === 'PENDING') {this.state = 'REJECTED';this.value = value;      this.rejectedCallbacks.map(cb =&gt; cb(value));    }}then(onFulfilled, onRejected) {if (this.state === 'PENDING') {this.resolvedCallbacks.push(onFulfilled);this.rejectedCallbacks.push(onRejected);    }    if (this.state === 'RESOLVED') {      onFulfilled(this.value);    }    if (this.state === 'REJECTED') {      onRejected(this.value);    }}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="问：js-脚本加载问题，async、defer-问题"><a href="#问：js-脚本加载问题，async、defer-问题" class="headerlink" title="问：js 脚本加载问题，async、defer 问题"></a>问：js 脚本加载问题，async、defer 问题</h2><ul><li>如果依赖其他脚本和 DOM 结果，使用 defer</li><li>如果与 DOM 和其他脚本依赖不强时，使用 async</li></ul><h2 id="问：如何判断一个对象是不是空对象？"><a href="#问：如何判断一个对象是不是空对象？" class="headerlink" title="问：如何判断一个对象是不是空对象？"></a>问：如何判断一个对象是不是空对象？</h2><p>Object.keys(obj).length === 0</p><p>手写题：在线编程，getUrlParams(url,key); 就是很简单的获取 url 的某个参数的问题，但要考虑边界情况，多个返回值等等</p><h2 id="问：-lt-script-src-’xxx’-’xxx’-gt-外部-js-文件先加载还是-onload-先执行，为什么？"><a href="#问：-lt-script-src-’xxx’-’xxx’-gt-外部-js-文件先加载还是-onload-先执行，为什么？" class="headerlink" title="问：<script src=’xxx’ ’xxx’/>外部 js 文件先加载还是 onload 先执行，为什么？"></a>问：&lt;script src=’xxx’ ’xxx’/&gt;外部 js 文件先加载还是 onload 先执行，为什么？</h2><p>onload 是所以加载完成之后执行的</p><h2 id="问：怎么加事件监听，两种"><a href="#问：怎么加事件监听，两种" class="headerlink" title="问：怎么加事件监听，两种"></a>问：怎么加事件监听，两种</h2><p>onclick 和 addEventListener</p><h2 id="问：事件传播机制（事件流）"><a href="#问：事件传播机制（事件流）" class="headerlink" title="问：事件传播机制（事件流）"></a>问：事件传播机制（事件流）</h2><p>冒泡和捕获</p><h3 id="（4）问：说一下原型链和原型链的继承吧"><a href="#（4）问：说一下原型链和原型链的继承吧" class="headerlink" title="（4）问：说一下原型链和原型链的继承吧"></a>（4）问：说一下原型链和原型链的继承吧</h3><ul><li>所有普通的 [[Prototype]] 链最终都会指向内置的 Object.prototype，其包含了 JavaScript 中许多通用的功能</li><li>为什么能创建 “类”，借助一种特殊的属性：所有的函数默认都会拥有一个名为 prototype 的共有且不可枚举的属性，它会指向另外一个对象，这个对象通常被称为函数的原型</li></ul><pre class="line-numbers language-none"><code class="language-none">function Person(name) {this.name = name;}Person.prototype.constructor = Person<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>在发生 new 构造函数调用时，会将创建的新对象的 [[Prototype]] 链接到 Person.prototype 指向的对象，这个机制就被称为原型链继承</p></li><li><p>方法定义在原型上，属性定义在构造函数上</p></li><li><p>首先要说一下 JS 原型和实例的关系：每个构造函数 （constructor）都有一个原型对象（prototype），这个原型对象包含一个指向此构造函数的指针属性，通过 new 进行构造函数调用生成的实例，此实例包含一个指向原型对象的指针，也就是通过 [[Prototype]] 链接到了这个原型对象</p></li><li><p>然后说一下 JS 中属性的查找：当我们试图引用实例对象的某个属性时，是按照这样的方式去查找的，首先查找实例对象上是否有这个属性，如果没有找到，就去构造这个实例对象的构造函数的 prototype 所指向的对象上去查找，如果还找不到，就从这个 prototype 对象所指向的构造函数的 prototype 原型对象上去查找</p></li><li><p>什么是原型链：这样逐级查找形似一个链条，且通过 [[Prototype]] 属性链接，所以被称为原型链</p></li><li><p>什么是原型链继承，类比类的继承：当有两个构造函数 A 和 B，将一个构造函数 A 的原型对象的，通过其 [[Prototype]] 属性链接到另外一个 B 构造函数的原型对象时，这个过程被称之为原型继承。</p><p><em>标准答案更正确的解释</em></p></li></ul><h4 id="什么是原型链？"><a href="#什么是原型链？" class="headerlink" title="什么是原型链？"></a>什么是原型链？</h4><p>当对象查找一个属性的时候，如果没有在自身找到，那么就会查找自身的原型，如果原型还没有找到，那么会继续查找原型的原型，直到找到 Object.prototype 的原型时，此时原型为 null，查找停止。这种通过 通过原型链接的逐级向上的查找链被称为原型链</p><h4 id="什么是原型继承？"><a href="#什么是原型继承？" class="headerlink" title="什么是原型继承？"></a>什么是原型继承？</h4><p>一个对象可以使用另外一个对象的属性或者方法，就称之为继承。具体是通过将这个对象的原型设置为另外一个对象，这样根据原型链的规则，如果查找一个对象属性且在自身不存在时，就会查找另外一个对象，相当于一个对象可以使用另外一个对象的属性和方法了。</p><h2 id="问：说下对-JS-的了解吧"><a href="#问：说下对-JS-的了解吧" class="headerlink" title="问：说下对 JS 的了解吧"></a>问：说下对 JS 的了解吧</h2><p>是基于原型的动态语言，主要独特特性有 this、原型和原型链。</p><p>JS 严格意义上来说分为：语言标准部分（ECMAScript）+ 宿主环境部分</p><h3 id="语言标准部分"><a href="#语言标准部分" class="headerlink" title="语言标准部分"></a>语言标准部分</h3><p>2015 年发布 ES6，引入诸多新特性使得能够编写大型项目变成可能，标准自 2015 之后以年号代号，每年一更</p><h3 id="宿主环境部分"><a href="#宿主环境部分" class="headerlink" title="宿主环境部分"></a>宿主环境部分</h3><ul><li>在浏览器宿主环境包括 DOM + BOM 等</li><li>在 Node，宿主环境包括一些文件、数据库、网络、与操作系统的交互等</li></ul><h2 id="问：数组能够调用的函数有那些？"><a href="#问：数组能够调用的函数有那些？" class="headerlink" title="问：数组能够调用的函数有那些？"></a>问：数组能够调用的函数有那些？</h2><ul><li>push</li><li>pop</li><li>splice</li><li>slice</li><li>shift</li><li>unshift</li><li>sort</li><li>find</li><li>findIndex</li><li>map/filter/reduce 等函数式编程方法</li><li>还有一些原型链上的方法：toString/valudOf</li></ul><h2 id="问：如何判断数组类型"><a href="#问：如何判断数组类型" class="headerlink" title="问：如何判断数组类型"></a>问：如何判断数组类型</h2><p>Array.isArray</p><h2 id="问：函数中的-arguments-是数组吗？类数组转数组的方法了解一下？"><a href="#问：函数中的-arguments-是数组吗？类数组转数组的方法了解一下？" class="headerlink" title="问：函数中的 arguments 是数组吗？类数组转数组的方法了解一下？"></a>问：函数中的 arguments 是数组吗？类数组转数组的方法了解一下？</h2><p>是类数组，是属于鸭子类型的范畴，长得像数组，</p><ul><li>… 运算符</li><li>Array.from</li><li>Array.prototype.slice.apply(arguments)</li></ul><h2 id="问：用过-TypeScript-吗？它的作用是什么？"><a href="#问：用过-TypeScript-吗？它的作用是什么？" class="headerlink" title="问：用过 TypeScript 吗？它的作用是什么？"></a>问：用过 TypeScript 吗？它的作用是什么？</h2><p>为 JS 添加类型支持，以及提供最新版的 ES 语法的支持，是的利于团队协作和排错，开发大型项目</p><h2 id="问：PWA-使用过吗？serviceWorker-的使用原理是啥？"><a href="#问：PWA-使用过吗？serviceWorker-的使用原理是啥？" class="headerlink" title="问：PWA 使用过吗？serviceWorker 的使用原理是啥？"></a>问：PWA 使用过吗？serviceWorker 的使用原理是啥？</h2><p>渐进式网络应用（PWA）是谷歌在 2015 年底提出的概念。基本上算是 web 应用程序，但在外观和感觉上与原生 app 类似。支持 PWA 的网站可以提供脱机工作、推送通知和设备硬件访问等功能。</p><p>Service Worker 是浏览器在后台独立于网页运行的脚本，它打开了通向不需要网页或用户交互的功能的大门。现在，它们已包括如推送通知和后台同步等功能。将来，Service Worker 将会支持如定期同步或地理围栏等其他功能。本教程讨论的核心功能是拦截和处理网络请求，包括通过程序来管理缓存中的响应。</p><h2 id="问：ES6-之前使用-prototype-实现继承"><a href="#问：ES6-之前使用-prototype-实现继承" class="headerlink" title="问：ES6 之前使用 prototype 实现继承"></a>问：ES6 之前使用 prototype 实现继承</h2><p>Object.create() 会创建一个 “新” 对象，然后将此对象内部的 [[Prototype]] 关联到你指定的对象（Foo.prototype）。Object.create(null) 创建一个空 [[Prototype]] 链接的对象，这个对象无法进行委托。</p><pre class="line-numbers language-none"><code class="language-none">function Foo(name) {this.name = name;}Foo.prototype.myName = function () {return this.name;}// 继承属性，通过借用构造函数调用function Bar(name, label) {Foo.call(this, name);this.label = label;}// 继承方法，创建备份Bar.prototype = Object.create(Foo.prototype);// 必须设置回正确的构造函数，要不然在会发生判断类型出错Bar.prototype.constructor = Bar;// 必须在上一步之后Bar.prototype.myLabel = function () {return this.label;}var a = new Bar("a", "obj a");a.myName(); // "a"a.myLabel(); // "obj a"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="问-如果一个构造函数，bind-了一个对象，用这个构造函数创建出的实例会继承这个对象的属性吗？为什么？"><a href="#问-如果一个构造函数，bind-了一个对象，用这个构造函数创建出的实例会继承这个对象的属性吗？为什么？" class="headerlink" title="问:如果一个构造函数，bind 了一个对象，用这个构造函数创建出的实例会继承这个对象的属性吗？为什么？"></a>问:如果一个构造函数，bind 了一个对象，用这个构造函数创建出的实例会继承这个对象的属性吗？为什么？</h2><p>不会继承，因为根据 this 绑定四大规则，new 绑定的优先级高于 bind 显示绑定，通过 new 进行构造函数调用时，会创建一个新对象，这个新对象会代替 bind 的对象绑定，作为此函数的 this，并且在此函数没有返回对象的情况下，返回这个新建的对象</p><h2 id="3-箭头函数和普通函数有啥区别？箭头函数能当构造函数吗？"><a href="#3-箭头函数和普通函数有啥区别？箭头函数能当构造函数吗？" class="headerlink" title="(3)箭头函数和普通函数有啥区别？箭头函数能当构造函数吗？"></a>(3)箭头函数和普通函数有啥区别？箭头函数能当构造函数吗？</h2><ul><li><p>普通函数通过 function 关键字定义， this 无法结合词法作用域使用，在运行时绑定，只取决于函数的调用方式，在哪里被调用，调用位置。（取决于调用者，和是否独立运行）</p></li><li><p>箭头函数使用被称为 “胖箭头” 的操作 =&gt; 定义，箭头函数不应用普通函数 this 绑定的四种规则，而是根据外层（函数或全局）的作用域来决定 this，且箭头函数的绑定无法被修改（new 也不行）。</p></li><li><p>箭头函数常用于回调函数中，包括事件处理器或定时器</p></li><li><p>箭头函数和 var self = this，都试图取代传统的 this 运行机制，将 this 的绑定拉回到词法作用域</p></li><li><p>没有原型、没有 this、没有 super，没有 arguments，没有 new.target</p></li><li><p>不能通过 new 关键字调用</p></li><li><p>一个函数内部有两个方法：[[Call]] 和 [[Construct]]，在通过 new 进行函数调用时，会执行 [[construct]] 方法，创建一个实例对象，然后再执行这个函数体，将函数的 this 绑定在这个实例对象上<br>当直接调用时，执行 [[Call]] 方法，直接执行函数体<br>箭头函数没有 [[Construct]] 方法，不能被用作构造函数调用，当使用 new 进行函数调用时会报错。</p></li></ul><pre class="line-numbers language-none"><code class="language-none">function foo() {  return (a) =&gt; {  console.log(this.a);  }  }var obj1 = {a: 2}var obj2 = {a: 3}var bar = foo.call(obj1);bar.call(obj2);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="问：知道-ES6-的-Class-嘛？Static-关键字有了解嘛"><a href="#问：知道-ES6-的-Class-嘛？Static-关键字有了解嘛" class="headerlink" title="问：知道 ES6 的 Class 嘛？Static 关键字有了解嘛"></a>问：知道 ES6 的 Class 嘛？Static 关键字有了解嘛</h2><p>为这个类的函数对象直接添加方法，而不是加在这个函数对象的原型对象上</p><h3 id="（3）问：事件循环机制-（Event-Loop）"><a href="#（3）问：事件循环机制-（Event-Loop）" class="headerlink" title="（3）问：事件循环机制 （Event Loop）"></a>（3）问：事件循环机制 （Event Loop）</h3><p>事件循环机制从整体上告诉了我们 JavaScript 代码的执行顺序 Event Loop 即事件循环，是指浏览器或 Node 的一种解决 javaScript 单线程运行时不会阻塞的一种机制，也就是我们经常使用异步的原理。</p><p>先执行宏任务队列，然后执行微任务队列，然后开始下一轮事件循环，继续先执行宏任务队列，再执行微任务队列。</p><ul><li>宏任务：script/setTimeout/setInterval/setImmediate/ I/O / UI Rendering</li><li>微任务：process.nextTick()/Promise<br>上诉的 setTimeout 和 setInterval 等都是任务源，真正进入任务队列的是他们分发的任务。</li></ul><p><strong>优先级</strong></p><ul><li>setTimeout = setInterval 一个队列</li><li>setTimeout &gt; setImmediate</li><li>process.nextTick &gt; Promise</li></ul><pre class="line-numbers language-none"><code class="language-none">for (const macroTask of macroTaskQueue) {handleMacroTask();for (const microTask of microTaskQueue) {handleMicroTask(microTask);}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="（2）手写题：数组扁平化"><a href="#（2）手写题：数组扁平化" class="headerlink" title="（2）手写题：数组扁平化"></a>（2）手写题：数组扁平化</h3><pre class="line-numbers language-none"><code class="language-none">function flatten(arr) {let result = [];for (let i = 0; i &lt; arr.length; i++) {if (Array.isArray(arr[i])) {result = result.concat(flatten(arr[i]));} else {result = result.concat(arr[i]);}}return result;}const a = [1, [2, [3, 4]]];console.log(flatten(a));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="手写题：实现柯里化"><a href="#手写题：实现柯里化" class="headerlink" title="手写题：实现柯里化"></a>手写题：实现柯里化</h2><p>预先设置一些参数</p><p>柯里化是什么：是指这样一个函数，它接收函数 A，并且能返回一个新的函数，这个新的函数能够处理函数 A 的剩余参数</p><pre class="line-numbers language-none"><code class="language-none">function createCurry(func, args) {var argity = func.length;var args = args || [];return function () {var \_args = [].slice.apply(arguments);args.push(...\_args);    if (args.length &lt; argity) {      return createCurry.call(this, func, args);    }    return func.apply(this, args);}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="手写题：数组去重"><a href="#手写题：数组去重" class="headerlink" title="手写题：数组去重"></a>手写题：数组去重</h2><p><code>Array.from(new Set([1, 1, 2, 2]))</code></p><h2 id="问：let-闭包"><a href="#问：let-闭包" class="headerlink" title="问：let 闭包"></a>问：let 闭包</h2><p>let 会产生临时性死区，在当前的执行上下文中，会进行变量提升，但是未被初始化，所以在执行上下文执行阶段，执行代码如果还没有执行到变量赋值，就引用此变量就会报错，此变量未初始化。</p><h2 id="问：变量提升"><a href="#问：变量提升" class="headerlink" title="问：变量提升"></a>问：变量提升</h2><p>函数在运行的时候，会首先创建执行上下文，然后将执行上下文入栈，然后当此执行上下文处于栈顶时，开始运行执行上下文。</p><p>在创建执行上下文的过程中会做三件事：创建变量对象，创建作用域链，确定 this 指向，其中创建变量对象的过程中，首先会为 arguments 创建一个属性，值为 arguments，然后会扫码 function 函数声明，创建一个同名属性，值为函数的引用，接着会扫码 var 变量声明，创建一个同名属性，值为 undefined，这就是变量提升 ** 问：如何看待 PWA App、原生 App 以及 Flutter 和 React Native 这种前端驱动的开发模式？</p><h2 id="instance-如何使用"><a href="#instance-如何使用" class="headerlink" title="instance 如何使用"></a>instance 如何使用</h2><p>左边可以是任意值，右边只能是函数</p><p><code>'hello tuture' instanceof String // false</code></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hello</title>
      <link href="/posts/hello.html"/>
      <url>/posts/hello.html</url>
      
        <content type="html"><![CDATA[<h2 id="hello-world"><a href="#hello-world" class="headerlink" title="hello world"></a>hello world</h2><blockquote><p>测试 hexo 博客发布</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 工具类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hello-world </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/hello-world.html"/>
      <url>/posts/hello-world.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new "My New Post"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
